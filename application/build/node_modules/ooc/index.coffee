fs = require "fs"
cp = require "child_process"

class Build

    constructor: (@sourceDir, @mainClass, @debugOutput, @releaseOutput, @instanceName) ->
        @_trimSourceDir()
        @paths     = new PathList   @
        @files     = new FileList   @
        @tempFile  = new TempFile   @
        @debugFile = new DebugFile  @, @_onDebugComplete

    _onDebugComplete: (error) =>
        if error
            @tempFile.remove()
            return
        console.log "Compiled: #{@debugOutput}"
        if @releaseOutput
            @releaseFile = new ReleaseFile @, @_onReleaseComplete
        else
            @tempFile.remove()

    _onReleaseComplete: (error) =>
        if not error
            console.log "Compiled: #{@releaseOutput}"
        @tempFile.remove()

    _trimSourceDir: =>
        return if @sourceDir[@sourceDir.length-1] isnt "/"
        @sourceDir = @sourceDir.substring 0, @sourceDir.length - 1

class PathList extends Array

    constructor: (@build) ->
        @_readImports @build.mainClass
        @push @build.mainClass

    _readImports: (path) =>
        raw   = fs.readFileSync path, "utf8"
        lines = raw.split "\n"
        for line in lines
            if line.indexOf("import ") is 0
                path = @_getPath line
                continue if @indexOf(path) > -1
                @_readImports path
                @push path

    _getPath: (line) =>
        dir   = @build.sourceDir
        dir   = dir + "/" if dir[dir.length-1] isnt "/"
        path  = line.replace "import ", ""
        path  = path.replace /\./g, "/"
        path  = dir + path + ".coffee"
        return path

class FileList extends Array

    constructor: (@build) ->
        for path in @build.paths
            @push new CoffeeFile path, @build

        max = 1000
        for i in [0...max]
            if @_sort()
                break
            if i is max
                console.log "Warning: Attempted to sort imports #{max} times."

    _sort: ->
        for f1 in @
            for path in f1.imports
                f2 = @_getFileByPath path
                i2 = @indexOf f2
                if _i < i2
                    @_move f2, i2, _i
                    return false
        return true

    _move: (file, oldIndex, newIndex) ->
        @splice oldIndex, 1
        @splice newIndex, 0, file


    _getFileByPath: (path) ->
        for file in @
            if file.path is path
                return file

    _print: ->
        for file in @
            console.log file.path
        console.log "-------"

class CoffeeFile

    constructor: (@path, @build) ->
        @raw     = fs.readFileSync path, "utf8"
        @lines   = @raw.split "\n"
        @imports = @_getImports()
        @package = @_getPackage @path
        @clazz   = @_getClass @path
        @cIndex  = @_getClassIndex()
        @cLine   = @lines[@cIndex]
        @_insertLocals()
        @_insertClassPackage()
        @_insertExtendsPackage()
        @_removeImports()
        @code    = @lines.join "\n"

    _insertExtendsPackage: =>
        text    = @lines[@cIndex]
        return unless text
        return unless text.match " extends "
        parts   = text.split " extends "
        clazz   = parts[parts.length-1]
        pack    = @_getExtensionPackage clazz
        pack   += "." if pack.length > 0
        @lines[@cIndex] = text.replace " extends ", " extends "+ pack

    _getExtensionPackage: (clazz) =>
        for path in @imports
            pClazz = @_getClass path
            if pClazz is clazz
                pack = @_getPackage path
                return pack

    _insertClassPackage: =>
        text  = @lines[@cIndex]
        return unless text
        pack  = @package
        pack += "." if pack.length > 0
        @lines[@cIndex] = text.replace @clazz, pack + @clazz

    _getClassIndex: =>
        for line in @lines
            if line.indexOf("class ") is 0
                return _i

    _removeImports: =>
        for i in [@lines.length-1..0]
            line = @lines[i]
            if line.indexOf("import ") is 0
                @lines.splice i, 1

    _insertLocals: =>
        for path in @imports
            pack  = @_getPackage path
            clazz = @_getClass   path
            continue unless @_usedClass clazz
            pack += "." if pack.length > 0
            line  = "    " + clazz + " = " + pack + clazz
            @lines.splice @cIndex+1, 0, line

    _usedClass: (clazz) =>
        for i in [@cIndex+1...@lines.length-1]
            line = @lines[i]
            if line.match clazz
                return true
        return false

    _getImports: =>
        a = []
        for line in @lines
            if line.indexOf("import ") is 0
                path = @_getPath line
                a.push path
        return a

    _getPath: (line) =>
        dir   = @build.sourceDir
        dir   = dir + "/" if dir[dir.length-1] isnt "/"
        path  = line.replace "import ", ""
        path  = path.replace /\./g, "/"
        path  = dir + path + ".coffee"
        return path

    _getClass: (path) =>
        parts = path.split "/"
        clazz = parts[parts.length-1]
        clazz = clazz.replace ".coffee", ""
        return clazz


    _getPackage: (path) =>
        path  = path.replace "import ", ""
        path  = path.replace @build.sourceDir + "/", ""
        parts = path.split "/"
        parts.pop()
        pack  = parts.join "."
        return pack

class TempFile

    constructor: (@build) ->
        output = @_getOutput()
        @file  = @_write output

    remove: ->
        fs.unlinkSync @file
        files = fs.readdirSync ".tmp", "*.tmp"
        if files.length is 0
            fs.rmdirSync ".tmp"

    _write: (output) ->
        name = @_getTempName @build.debugOutput
        file = "#{name}.tmp"
        fs.writeFileSync file, output
        return file

    _getOutput: ->
        output = []
        output.push @_getNameSpaces()
        for file in @build.files
            output.push file.code + "\n"
        output  = output.join("")
        main    = @_getMain()
        return output if typeof @build.instanceName isnt "string"
        return output unless typeof main.cLine is "string" and main.cLine.length > 0
        pack    = main.package
        pack   += "." if pack.length > 0
        name    = pack + main.clazz
        line    = "\n #{@build.instanceName} = new #{name}()" if name
        output += line
        return output

    _getMain: =>
        for file in @build.files
            if file.path is @build.mainClass
                return file

    _getTempName: (path) =>
        if not fs.existsSync ".tmp"
            fs.mkdirSync ".tmp"
        parts = path.split "/"
        name  = parts[parts.length-1]
        name  = name.split(".")[0]
        name += "-" + parseInt( Math.random() * 1000000 )
        name  = ".tmp/" + name
        return name

    _getNameSpaces: ->
        a = []
        for file in @build.files
            if file.package
                parts = file.package.split "."
                b     = []
                for part in parts
                    b.push part
                    s = b.join "."
                    if a.indexOf(s) is -1
                        a.push s
        s = ""
        a = a.sort()
        for ns in a
            s += ns + " = this." + ns + " or {}" + "\n"
        return s + "\n"

class DebugFile

    constructor: (@build, callback) ->
        parts   = @build.debugOutput.split "/"
        file    = parts[parts.length-1]
        path    = @build.debugOutput.replace file, ""

        command  = "coffee -b -j #{file}"
        command += " -o #{path}" if path.length > 0
        command += " -c #{@build.tempFile.file} "
        cp.exec command, (error, stdout, stderr) ->
            console.log error  if error
            console.log stdout if stdout
            console.log stderr if stderr
            callback error

class ReleaseFile

    constructor: (@build, callback) ->
        command = "ccjs #{@build.debugOutput} > #{@build.releaseOutput}"
        cp.exec command, (error, stdout, stderr) ->
            console.log error  if error
            console.log stdout if stdout
            console.log stderr if stderr
            callback error

module.exports.compile = (sourceDir, mainClass, debugOutput, releaseOutput, instanceName) ->
    new Build sourceDir, mainClass, debugOutput, releaseOutput, instanceName
